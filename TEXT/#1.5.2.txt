*******１．５．２　文字のカウント*******
***次のプログラムは文字数を数えるためのものである、これは複写のプログラムに
    少し手を加えたものになっている。
***     #include <stdio.h>
        int main ()
        {
            long nc;
            nc = 0;
            while(getchar() != EOF)
                ++nc;
            printf("%ld\n",nc);
        }
***次の文　++nc
    には新しい演算子＋＋が出ているがこれは１だけの増分（インクリメント）を表す(出てたけど✋)
    ここはnc = nc + 1; と書いてもよいが、　++ncのほうが短くてしかもより一層能率的なことがおおい。
    これに対応する演算子としては、(対照的な)1だけの減少デクリメントを表すーーがある。
***＋＋およびーーという演算子は前置演算子（++nc）でもよいし後置演算子（nc++）でもよい。
***どっちでもいいとか言ってるけど
    使うﾀｲﾐﾝｸﾞによって結果が変わることに注意前置でも後置でもインクリメント
    デクリメントがおこなわれることに違いはないが、ﾀｲﾐﾝｸﾞによって下記のように異なる結果が
    出力されることに注意
        #include <stdio.h>

        int main() {
            int x = 5;
            int y = 5;

            printf("前置インクリメント: %d\n", ++x); // xは6になり、6が出力される
            printf("後置インクリメント: %d\n", y++); // yは5のまま出力され、その後6になる

            return 0;
        }
            前置インクリメント: 6
            後置インクリメント: 5
***先の文字カウントのプログラムではカウントはintではなくlong変数に蓄積(格納)する。　
    long整数は少なくとも32ビットである。機種によってはintとlongは同じサイズであるが
    他の機種ではintは16ビットでその最大値は32767であり比較的小さな入力でintのカウンタが
    オーバーフローしかねない。
***オーバーフローについて
    オーバーフローは、変数がその型で表現できる最大値を超えたときに発生する現象です。
    例えば、16ビットのint型変数は最大値が32767ですが、それを超える値を格納しようとするとオーバーフローが発生します。
***オーバーフローの発生後の動向と結果
    ***符号付き整数の場合
        オーバーフローが発生すると、値は負の最小値に巻き戻ります。例えば、int型変数が32767を超えると、次の値は-32768になります。
        例: int x = 32767; x++; の結果、xは-32768になります。
    ***符号なし整数の場合
        オーバーフローが発生すると、値は0に巻き戻ります。
        例えば、unsigned int型変数が最大値を超えると、次の値は0になります。
        例: unsigned int y = 65535; y++; の結果、yは0になります。
    ***簡単な例
        #include <stdio.h>

        int main() {
            int x = 32767; // 16ビットのint型の最大値
            x++; // オーバーフローが発生
            printf("オーバーフロー後の値: %d\n", x); // -32768が出力される

            return 0;
        }
         オーバーフロー後の値: -32768
***変換指定子％ｌｄは対応する引数がlong整数であることをprintfに伝えるためのものである。
***ところで、これよりさらに大きな数字を扱うにはdouble(倍長のfloat)が使える。
    ループ表現をするもう一つの別のやり方を示すために、次にwhileの代わりにforを使ってみよう。
***//入力される文字をカウントfor版
    #include <stdio.h>
    int main()
    {
        double nc; //doubleがた変数ncを宣言 
        for ( nc = 0; getchar() != EOF ; ++nc )
        //初期値　nc = 0
        //条件　getchar() != EOF
        //カウンタ　++nc
            ;   //for文の本体　；　は　空　を意味する。
        printf("%.0f\n", nc); 
    }
***printfではfloatとdoubleの両方に%fをつかう。％.0fでは存在しない小数部の印字が抑止される。
***ここではforループの本体は空である。これはすべての仕事がテストとインクリメントの部分でおこなわれているから
    である。しかしCの文法規則ではfor文には本体が必要とされる。
***この要求を満たしているのは独立したセミコロン、技術的にいえば空文である。
    これは見やすくするために別の行に書くとよい。
***この文字数をカウントするプログラムを離れる前に注意しておきたいことは
    入力に何も文字がなければ最初にgetcharを呼ぶときにwhileあるいはforのテスト結果が偽となるから
    このプログラムでゼロという当然の答えが得られることである。
***whileやforのいい点の1つはループの本体に入る前にその頭のところでテストがおこなわれることである。
    つまり何もすることがなければループの本体に入ることもなく、何もおこなわれないのである。
    ”文字なし”というような入力が来た時でもプログラムはちゃんと対応できるものでなければならない。
    while文とfor文は境界条件においてもきちんとした処理がおこなわれることを確実にするのに役立つ。
    
*******はじめに*******
    Cは汎用のプログラミング言語UNIXシステムと密接に関係するものとされいるがこれはCがUNIXシステムの上で開発されUNIXとその上で走る
    プログラムの大部分がCで書かれているためである。Cに関する重要なアイデアの大部分はBCPL言語に由来する。
***Martin Richardが開発したBCPL言語、このBはDEC PDP-7上の最初のUNIXシステム用に
***Ken Thompsonが1970年に開発したものである。
    BCPLおよびBは”型のない”言語である。それとは対象的に、
***Cには豊富なデータ型がある。
    基本的な型は文字及びいくつかのサイズの整数や浮動小数点数である。    
    さらに、ポインタ、配列、構造体、共用体(union)によって作られる副次的なデータ型のハイアラーキもある。
    演算子と被演算数で構成される式も使えるし代入文あるいは関数呼び出しを含む任意の式は文となりうる。
    Cには構造のスッキリしたプログラムを書くのに必要な基本的な流れ制御の構文として
    文のグループ化、判定（if-else）、一群の可能な場合のうちのひとつの選択をおこなう文（switch）、始め（while,for）あるいは終わりに（do）
    終了チェックのあるループ構造、早めにループから脱出する文（break）もある。
***関数が返す値は基本形、構造体、共用体、あるいはポインタのいずれでもよい。
    関数はどれも再帰的に呼べる。その局所変数は普通自動的に、すなわち呼び出されるごとに新たに作り出される。
    関数の定義はネストにしてはならないが、変数はブロック構造風に宣言してよい。
    Cプログラムの関数は別々にコンパイルされる別々のソースファイルに入れることもできる。
    変数は関数の内部にあってもいいし外部にあるが一つのソースファイルの中でのみ既知でもよく、あるいはプログラム
    全体から見えるものであっても構わない。
    前処理の段階ではプログラムテキスト上でのマクロの置き換え、他のソースファイルの取り込み、条件付きコンパイルが行われる。
***C言語は比較的低水準の言語である。この性格付けは非難の意味を込めているのではない。
    これは単にCが普通のコンピュータで扱う種類の、すなわち文字、数、アドレスを扱えるようになっているという意味である。
    もちろん、これらのデータを組み合わせて現実の機械で実行されるような普通の算術論理演算でいろいろな処理を行うことができる。
***Cには全体でひとまとまりと考えられる文字列、集合、リスト、配列といった複合データを直接に扱う操作は用意されていない。
    構造体だけはひとまとめにしてコピーできるが、配列あるいは文字列全体を取り扱う操作はないのである。
    C言語で定義する記憶割り当て機能は関数の局所変数により与えられる静的な割り当てとスタックだけである。
    ヒープとかガベージコレクションの機能はない最後に、C自体には入出力の機能はない。READ文とかWRITE文はないし、組み込みの
    ファイルアクセス法もないのである。これらのより高水準な機構はすべてあからさまに関数を呼ぶことで実現しなければならない。
    しかし大抵のC処理系にはかなりまとまった標準的な入出力関数が用意されている。
    同様にCにはテスト、ループ、グループ化、副プログラムといった単純明快な一本糸の制御機構があるだけで、多重プログラミング、
    並行処理、コルーチンの機能はない。
***こうした特徴がないこと（２つの文字を比較するのにいちいち関数を呼ばなければならない）
    は重大な欠陥に見えるかもしれないが、言語仕様を適当な大きさに抑えることの利点は大きい。
    Cは比較的小さい言語であるからその仕様は小さいスペースで記述でき、学ぶのも短期間で可能である
    プログラマがこの言語全体を見て、理解し、これを本当に常時使うことも期待できる
***さて、これまで長年に渡ってCの定義はプログラミング言語Cという本書の第1版の参照マニュアルに出ているものであった。
    これに対してアメリカ国内の標準協会（ANSI=American National Stadards Institute）は
***1983年にCに関する現代的で総括的な定義をおこなう目的の委員会を発足させた。
    こうして生まれた定義、ANSI標準規格、すなわち
***ANSI Cは1988年末に承認された。
    この標準で定められている機能の大部分は最近のコンパイラにすでにサポートされているものである。
    この標準規格はもちろん元の参照マニュアルに基づいている。言語自体はほとんど変えられていない。
***標準化の目的の一つは既存のプログラムの大部分が既存のまま通用するようにし、それがダメな場合はコンパイラで新しい仕様についての
    警告が出せるようにすることであった。
    多くのプログラマにとって最も重要な変化は関数を宣言し定義するときの新しい構文である。今度は関数の宣言に関数の引数の記述を含めることが
    可能になった。このため関数定義の構文もそれに合うように変えられている。この情報の追加によりコンパイラでは引数の不一致によって
    生ずるエラーを検知するのがずっと容易になった。われわれの経験ではこれはC言語への非常に有用な追加機能である。
    これ以外の変更はいずれも小さいものでしかない。
    これまでにも広く使われてきた構造体の代入と列挙（enumeration）はの機能は正式にC言語の一部
    になった。浮動小数点の計算は今度は単精度でも可能となる。
    演算、特に符号なしの型の計算の扱いが明確になった。
    プリプロセッサは前よりきめ細やかなものになっている。
    これらの変更の大部分は多くのプログラマにとってはごく僅かな影響しかもたらさないであろう。
***この標準規格の2番目の意義にはCに付随するライブラリの定義の明確化である。
    これにはOSへのアクセスたとえばファイルの読み書き、書式付き入出力、記憶割り当て、文字列操作などのための関数が定義されている。
    関数やデータ型の宣言に一様にアクセスするための標準ヘッダの集まりも規定された。ホストシステムとのやり取りにこのライブラリを使う
    プログラムは互換性のある振る舞いをすることがこれで保証される。このライブラリの大部分はUNIXの標準入出力ライブラリをモデルとし、ほとんど
    それに合わせてある。これは本書の第1版にも説明してあるライブラリでありUNIX以外のシステムでも同様に広く使われているものである。
    これについても多くのプログラマはあまり変化を感じないであろう。
***Cが提供するデータ型と制御構造は大抵のコンピュータで直接にサポートされているから、自己完結型のプログラムを作るのに必要な実行時ライブラリは
    小さい。標準ライブラリ関数は明示的に呼ばれるだけであるため、必要がなければ使わなくて済む。その大部分はCで書けるからそこに隠されている
    OS機能の細かな点を除けばそれら自身は移植可能である。
***Cは多くのコンピュータの能力にマッチしたものであるが特定の計算機アーキテクチャとは独立である。したがって少し注意すれば移植可能な
    プログラム、すなわち変更なしにいろいろなハードウエア上で走りうるプログラムを書くのは容易である。この標準化のおかげで移植上で問題
    となる点が明確になり、プログラムを走らせる計算機に固有な一群の定数を決めることが可能になった。
***Cは強く型付けされた言語ではないがその発展の過程で型のチェックは強化されてきた。
    Cのもとの定義ではポインタと整数の相互交換は好ましくないとされながらも許してきたこの項目はかなり前に
    削除されたが今度の標準規格では、よくできたコンパイラでは、すでに強制してきた適切な宣言と明示的な変換
    が要求されるようになっている。この新しい関数宣言は、この方向へのもう一つの進歩である。
***コンパイラでは型不一致のエラーの大部分に対しては警告が出るであろうが互換性のないデータ型の自動変換はしない。
    しかしCプログラマは自分が何をしようとしているか知っているという基本哲学は残されている。
***Cが要求するのは自分の意図を明確に伝えることである。
***ところで、どんな言語にも欠点はある。演算子のなかには誤った強さを持つものがある。
    その構文にはもっとよく設計できたはずの部分もある。それにもかかわらずプログラミングの広範囲でさまざまな
    応用に対しCがきわめて効率的で表現力のある言語だということは実績が示している。
***


